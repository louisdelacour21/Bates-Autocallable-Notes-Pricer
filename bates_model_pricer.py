# -*- coding: utf-8 -*-
"""Bates_model_Pricer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eEJlAsYx8lRFwGjqVutBssP5KPsvZzOq
"""

import QuantLib as ql
import numpy as np
import scipy.optimize as opt
from scipy.stats import norm


class BatesPricer:
    """
    A comprehensive class for pricing autocallable structured products using the Bates model
    (Heston stochastic volatility with jumps).
    """

    def __init__(self, valuation_date, spot_price, strike_price, risk_free_rate, dividend_yield):
        """
        Initialize the Bates pricer with market data.

        Args:
            valuation_date: QuantLib Date object for valuation
            spot_price: Current underlying asset price
            strike_price: Strike price for the product
            risk_free_rate: Risk-free interest rate
            dividend_yield: Dividend yield of the underlying
        """
        self.valuation_date = valuation_date
        self.spot_price = spot_price
        self.strike_price = strike_price
        self.calendar = ql.TARGET()
        self.day_counter = ql.Actual360()

        # Set up QuantLib environment
        ql.Settings.instance().evaluationDate = valuation_date

        # Create yield curves
        self.risk_free_curve = ql.YieldTermStructureHandle(
            ql.FlatForward(valuation_date, risk_free_rate, self.day_counter)
        )
        self.dividend_curve = ql.YieldTermStructureHandle(
            ql.FlatForward(valuation_date, dividend_yield, self.day_counter)
        )

    def generate_paths_with_jumps(self, observation_dates, bates_params, num_paths):
        """
        Generate Monte Carlo paths using the Bates model (Heston + jumps).

        Args:
            observation_dates: List of dates for path observations
            bates_params: Dictionary with Bates parameters
            num_paths: Number of Monte Carlo paths to generate

        Returns:
            Array of simulated paths
        """
        # Extract parameters
        v0 = bates_params['v0']
        kappa = bates_params['kappa']
        theta = bates_params['theta']
        sigma = bates_params['sigma']
        rho = bates_params['rho']
        jump_intensity = bates_params['jump_intensity']
        jump_mean = bates_params['jump_mean']
        jump_std = bates_params['jump_std']

        # Time grid
        time_grid = np.array([
            self.day_counter.yearFraction(observation_dates[0], date)
            for date in observation_dates
        ])

        dt = np.diff(time_grid)
        dt = np.insert(dt, 0, 0)  # Add initial time step

        # Initialize arrays
        paths = np.zeros(shape=(num_paths, len(time_grid)))
        variance_paths = np.zeros(shape=(num_paths, len(time_grid)))

        # Set initial conditions
        paths[:, 0] = self.spot_price
        variance_paths[:, 0] = v0

        # Risk-free rate and dividend yield
        r = self.risk_free_curve.zeroRate(observation_dates[-1], self.day_counter, ql.Continuous).rate()
        q = self.dividend_curve.zeroRate(observation_dates[-1], self.day_counter, ql.Continuous).rate()

        # Jump compensation
        jump_compensation = jump_intensity * (np.exp(jump_mean + 0.5 * jump_std**2) - 1)

        for i in range(1, len(time_grid)):
            # Generate random numbers
            Z1 = np.random.standard_normal(num_paths)
            Z2 = rho * Z1 + np.sqrt(1 - rho**2) * np.random.standard_normal(num_paths)

            # Generate jump components
            jump_times = np.random.poisson(jump_intensity * dt[i], num_paths)
            jump_sizes = np.zeros(num_paths)

            for path_idx in range(num_paths):
                if jump_times[path_idx] > 0:
                    # Sum of multiple jumps if they occur
                    individual_jumps = np.random.normal(jump_mean, jump_std, jump_times[path_idx])
                    jump_sizes[path_idx] = np.sum(individual_jumps)

            # Variance process (CIR process)
            variance_paths[:, i] = (variance_paths[:, i-1] +
                                  kappa * (theta - variance_paths[:, i-1]) * dt[i] +
                                  sigma * np.sqrt(variance_paths[:, i-1] * dt[i]) * Z2 +
                                  0.25 * sigma**2 * dt[i] * (Z2**2 - 1))

            # Ensure variance stays positive
            variance_paths[:, i] = np.maximum(variance_paths[:, i], 1e-8)

            # Asset price process with jumps
            drift = (r - q - jump_compensation - 0.5 * variance_paths[:, i-1]) * dt[i]
            diffusion = np.sqrt(variance_paths[:, i-1] * dt[i]) * Z1

            paths[:, i] = paths[:, i-1] * np.exp(drift + diffusion + jump_sizes)

        return paths

    def calibrate_bates_model(self, market_data, initial_params, parameter_bounds, optimizer=opt.differential_evolution):
        """
        Calibrate the Bates model to market volatility data.

        Args:
            market_data: Dictionary with 'expiration_dates', 'strikes', and 'volatilities'
            initial_params: Initial guess for Bates parameters [v0, kappa, theta, sigma, rho, lambda, mu_j, sigma_j]
            parameter_bounds: Bounds for optimization
            optimizer: Optimization algorithm to use

        Returns:
            Dictionary of calibrated parameters
        """
        def bates_call_price(S, K, T, r, q, v0, kappa, theta, sigma, rho, jump_intensity, jump_mean, jump_std):
            """
            Semi-analytical approximation for Bates model call option price.
            Uses series expansion for the jump component.
            """
            # Heston component (base case)
            try:
                # Create Heston process for base pricing
                heston_process = ql.HestonProcess(
                    self.risk_free_curve, self.dividend_curve,
                    ql.QuoteHandle(ql.SimpleQuote(S)),
                    v0, kappa, theta, sigma, rho
                )
                heston_model = ql.HestonModel(heston_process)
                heston_engine = ql.AnalyticHestonEngine(heston_model)

                # Create option for Heston pricing
                payoff = ql.PlainVanillaPayoff(ql.Option.Call, K)
                exercise = ql.EuropeanExercise(self.valuation_date + int(T * 365))
                option = ql.VanillaOption(payoff, exercise)
                option.setPricingEngine(heston_engine)

                heston_price = option.NPV()
            except:
                # Fallback to Black-Scholes if Heston fails
                vol_estimate = np.sqrt(v0)
                heston_price = self._black_scholes_call(S, K, T, r, q, vol_estimate)

            # Jump component correction (first-order approximation)
            jump_correction = 0
            if jump_intensity > 0:
                # Expected jump effect
                expected_jump_return = np.exp(jump_mean + 0.5 * jump_std**2) - 1
                jump_correction = S * np.exp(-q * T) * jump_intensity * T * expected_jump_return

                # Adjust for jump volatility effect
                jump_vol_effect = jump_intensity * T * (np.exp(2 * jump_mean + jump_std**2) -
                                                      2 * np.exp(jump_mean + 0.5 * jump_std**2) + 1)
                if jump_vol_effect > 0:
                    effective_vol = np.sqrt(v0 + jump_vol_effect / T)
                    bs_with_jumps = self._black_scholes_call(S, K, T, r, q, effective_vol)
                    jump_correction += (bs_with_jumps - heston_price) * 0.5

            return max(heston_price + jump_correction, max(S * np.exp(-q * T) - K * np.exp(-r * T), 0))

        def objective_function(params):
            """Objective function for calibration optimization."""
            v0, kappa, theta, sigma, rho, jump_intensity, jump_mean, jump_std = params

            # Parameter validation
            if v0 <= 0 or kappa <= 0 or theta <= 0 or sigma <= 0:
                return 1e6
            if abs(rho) >= 1 or jump_intensity < 0:
                return 1e6
            if 2 * kappa * theta < sigma**2:  # Feller condition
                return 1e6

            total_error = 0
            count = 0

            for i, expiration_date in enumerate(market_data['expiration_dates']):
                T = self.day_counter.yearFraction(self.valuation_date, expiration_date)
                r = self.risk_free_curve.zeroRate(expiration_date, self.day_counter, ql.Continuous).rate()
                q = self.dividend_curve.zeroRate(expiration_date, self.day_counter, ql.Continuous).rate()

                for j, strike in enumerate(market_data['strikes']):
                    market_vol = market_data['volatilities'][i][j]
                    market_price = self._black_scholes_call(self.spot_price, strike, T, r, q, market_vol)

                    model_price = bates_call_price(
                        self.spot_price, strike, T, r, q,
                        v0, kappa, theta, sigma, rho, jump_intensity, jump_mean, jump_std
                    )

                    error = (model_price - market_price) / market_price
                    total_error += error**2
                    count += 1

            return np.sqrt(total_error / count) if count > 0 else 1e6

        # Run optimization
        result = optimizer(objective_function, parameter_bounds, seed=42, maxiter=1000)

        calibrated_params = {
            'v0': result.x[0],
            'kappa': result.x[1],
            'theta': result.x[2],
            'sigma': result.x[3],
            'rho': result.x[4],
            'jump_intensity': result.x[5],
            'jump_mean': result.x[6],
            'jump_std': result.x[7]
        }

        return calibrated_params

    def _black_scholes_call(self, S, K, T, r, q, vol):
        """Helper function for Black-Scholes call option pricing."""
        if T <= 0:
            return max(S - K, 0)

        d1 = (np.log(S/K) + (r - q + 0.5*vol**2)*T) / (vol*np.sqrt(T))
        d2 = d1 - vol*np.sqrt(T)

        call_price = S*np.exp(-q*T)*norm.cdf(d1) - K*np.exp(-r*T)*norm.cdf(d2)
        return max(call_price, 0)

    def price_autocallable_note(self, product_specs, bates_params, num_paths=10000):
        """
        Price an autocallable note using Monte Carlo simulation with the Bates model.

        Args:
            product_specs: Dictionary containing product specifications
            bates_params: Dictionary with calibrated Bates parameters
            num_paths: Number of Monte Carlo paths

        Returns:
            Present value of the autocallable note
        """
        coupon_dates = product_specs['coupon_dates']
        notional = product_specs['notional']
        autocall_barrier = product_specs['autocall_barrier']
        coupon_barrier = product_specs['coupon_barrier']
        protection_barrier = product_specs['protection_barrier']
        coupon_rate = product_specs['coupon_rate']
        has_memory = product_specs['has_memory']
        past_fixings = product_specs.get('past_fixings', {})
        final_payoff_formula = product_specs.get('final_payoff_formula', lambda x: x / self.strike_price)

        # Check if product has already been called
        if self.valuation_date >= coupon_dates[-1]:
            return 0.0

        if self.valuation_date >= coupon_dates[0]:
            if max(past_fixings.values()) >= (autocall_barrier * self.strike_price):
                return 0.0

        # Set up observation dates
        future_dates = coupon_dates[coupon_dates > self.valuation_date]
        observation_dates = np.hstack((np.array([self.valuation_date]), future_dates))

        # Generate Monte Carlo paths with jumps
        paths = self.generate_paths_with_jumps(observation_dates, bates_params, num_paths)[:, 1:]

        # Include past fixings if any
        past_dates = coupon_dates[coupon_dates <= self.valuation_date]
        if past_dates.shape[0] > 0:
            past_fixings_array = np.array([past_fixings[date] for date in past_dates])
            past_fixings_array = np.tile(past_fixings_array, (paths.shape[0], 1))
            paths = np.hstack((past_fixings_array, paths))

        # Calculate payoffs for each path
        payoff_pvs = []
        expiration_date = coupon_dates[-1]
        memory_factor = int(has_memory)

        for path in paths:
            total_pv = 0.0
            unpaid_coupons = 0
            has_been_called = False

            for observation_date, underlying_level in zip(coupon_dates, (path / self.strike_price)):
                if has_been_called:
                    break

                payoff = 0.0

                # Final observation date logic
                if observation_date == expiration_date:
                    if underlying_level >= coupon_barrier:
                        payoff = notional * (1 + (coupon_rate * (1 + unpaid_coupons * memory_factor)))
                    elif underlying_level >= protection_barrier:
                        payoff = notional
                    else:
                        actual_level = underlying_level * self.strike_price
                        payoff = notional * final_payoff_formula(actual_level)

                # Intermediate observation dates
                else:
                    if underlying_level >= autocall_barrier:
                        payoff = notional * (1 + (coupon_rate * (1 + unpaid_coupons * memory_factor)))
                        has_been_called = True
                    elif underlying_level >= coupon_barrier:
                        payoff = notional * (coupon_rate * (1 + unpaid_coupons * memory_factor))
                        unpaid_coupons = 0
                    else:
                        unpaid_coupons += 1

                # Discount payoff to present value
                if observation_date > self.valuation_date:
                    discount_factor = self.risk_free_curve.discount(observation_date)
                    total_pv += payoff * discount_factor

            payoff_pvs.append(total_pv)

        return np.mean(np.array(payoff_pvs))

    def calculate_greeks(self, product_specs, bates_params, num_paths=10000, bump_size=0.01):
        """
        Calculate Greeks for the autocallable note using finite differences.

        Args:
            product_specs: Dictionary containing product specifications
            bates_params: Dictionary with calibrated Bates parameters
            num_paths: Number of Monte Carlo paths
            bump_size: Size of bump for finite difference calculation

        Returns:
            Dictionary of Greeks
        """
        base_price = self.price_autocallable_note(product_specs, bates_params, num_paths)

        # Delta (sensitivity to underlying price)
        original_spot = self.spot_price
        self.spot_price = original_spot * (1 + bump_size)
        up_price = self.price_autocallable_note(product_specs, bates_params, num_paths)

        self.spot_price = original_spot * (1 - bump_size)
        down_price = self.price_autocallable_note(product_specs, bates_params, num_paths)

        delta = (up_price - down_price) / (2 * original_spot * bump_size)
        gamma = (up_price - 2 * base_price + down_price) / (original_spot * bump_size)**2

        # Restore original spot
        self.spot_price = original_spot

        # Vega (sensitivity to initial volatility)
        bates_params_up = bates_params.copy()
        bates_params_up['v0'] = bates_params['v0'] * (1 + bump_size)
        vega_up = self.price_autocallable_note(product_specs, bates_params_up, num_paths)

        bates_params_down = bates_params.copy()
        bates_params_down['v0'] = bates_params['v0'] * (1 - bump_size)
        vega_down = self.price_autocallable_note(product_specs, bates_params_down, num_paths)

        vega = (vega_up - vega_down) / (2 * np.sqrt(bates_params['v0']) * bump_size)

        # Jump sensitivity
        bates_params_jump_up = bates_params.copy()
        bates_params_jump_up['jump_intensity'] = bates_params['jump_intensity'] * (1 + bump_size)
        jump_up = self.price_autocallable_note(product_specs, bates_params_jump_up, num_paths)

        jump_sensitivity = (jump_up - base_price) / (bates_params['jump_intensity'] * bump_size)

        return {
            'price': base_price,
            'delta': delta,
            'gamma': gamma,
            'vega': vega,
            'jump_sensitivity': jump_sensitivity
        }


def main_example():
    """
    Example usage of the BatesPricer class for pricing autocallable products.
    """
    print("=== Bates Model Autocallable Notes Pricing Example ===\n")

    # Market setup
    valuation_date = ql.Date(20, 7, 2024)
    spot_price = 79.98
    strike_price = 82
    risk_free_rate = 0.02
    dividend_yield = 0.028

    # Initialize pricer
    pricer = BatesPricer(valuation_date, spot_price, strike_price, risk_free_rate, dividend_yield)
    print(f"Valuation Date: {valuation_date}")
    print(f"Spot Price: ${spot_price}")
    print(f"Strike Price: ${strike_price}")
    print(f"Risk-free Rate: {risk_free_rate*100:.1f}%")
    print(f"Dividend Yield: {dividend_yield*100:.1f}%\n")

    # Market volatility data for calibration
    expiration_dates = [
        ql.Date(20, 1, 2025), ql.Date(20, 7, 2025),
        ql.Date(20, 1, 2026), ql.Date(20, 7, 2026), ql.Date(20, 1, 2027)
    ]

    strike_levels = [strike_price * x for x in [0.8, 0.9, 1.0, 1.1, 1.2]]
    # Higher volatilities to account for jump risk
    implied_volatilities = [[0.25, 0.22, 0.20, 0.23, 0.26] for _ in expiration_dates]

    market_data = {
        'expiration_dates': expiration_dates,
        'strikes': strike_levels,
        'volatilities': implied_volatilities
    }

    # Initial Bates parameters [v0, kappa, theta, sigma, rho, lambda, mu_j, sigma_j]
    initial_bates_params = [0.04, 2.0, 0.04, 0.3, -0.6, 0.5, -0.1, 0.2]
    parameter_bounds = [
        (0.01, 0.5),    # v0
        (0.1, 10.0),    # kappa
        (0.01, 0.5),    # theta
        (0.01, 1.0),    # sigma
        (-0.99, 0.99),  # rho
        (0.0, 5.0),     # jump_intensity
        (-0.5, 0.5),    # jump_mean
        (0.01, 1.0)     # jump_std
    ]

    print("Calibrating Bates model to market data...")
    bates_params = pricer.calibrate_bates_model(
        market_data, initial_bates_params, parameter_bounds
    )

    print("Calibrated Bates parameters:")
    for param, value in bates_params.items():
        print(f"  {param}: {value:.4f}")
    print()

    # Product specifications
    notional = 1000000.0
    coupon_rate = 0.06  # Higher coupon due to jump risk
    protection_barrier = 0.6
    has_memory = True

    # Generate coupon dates (semi-annual for 3 years)
    start_date = valuation_date
    first_coupon = pricer.calendar.advance(start_date, ql.Period(6, ql.Months))
    last_coupon = pricer.calendar.advance(start_date, ql.Period(3, ql.Years))
    coupon_schedule = ql.Schedule(
        first_coupon, last_coupon, ql.Period(ql.Semiannual),
        pricer.calendar, ql.ModifiedFollowing, ql.ModifiedFollowing,
        ql.DateGeneration.Forward, False
    )
    coupon_dates = np.array(list(coupon_schedule))

    print(f"Product Details:")
    print(f"Notional: ${notional:,.0f}")
    print(f"Coupon Rate: {coupon_rate*100:.1f}%")
    print(f"Protection Barrier: {protection_barrier*100:.0f}%")
    print(f"Memory Feature: {'Yes' if has_memory else 'No'}")
    print(f"Number of Observations: {len(coupon_dates)}\n")

    # Product 1: Conservative autocallable (high barriers)
    conservative_specs = {
        'coupon_dates': coupon_dates,
        'notional': notional,
        'autocall_barrier': 1.0,
        'coupon_barrier': 1.0,
        'protection_barrier': protection_barrier,
        'coupon_rate': coupon_rate,
        'has_memory': has_memory,
        'past_fixings': {},
        'final_payoff_formula': lambda x: x / strike_price
    }

    print("Pricing Conservative Autocallable Note...")
    conservative_pv = pricer.price_autocallable_note(conservative_specs, bates_params, num_paths=15000)

    # Product 2: Aggressive autocallable (lower barriers)
    aggressive_specs = {
        'coupon_dates': coupon_dates,
        'notional': notional,
        'autocall_barrier': 0.95,
        'coupon_barrier': 0.75,
        'protection_barrier': protection_barrier,
        'coupon_rate': coupon_rate,
        'has_memory': has_memory,
        'past_fixings': {},
        'final_payoff_formula': lambda x: x / strike_price
    }

    print("Pricing Aggressive Autocallable Note...")
    aggressive_pv = pricer.price_autocallable_note(aggressive_specs, bates_params, num_paths=15000)

    # Calculate Greeks for the conservative product
    print("Calculating Greeks for Conservative Note...")
    greeks = pricer.calculate_greeks(conservative_specs, bates_params, num_paths=10000)

    # Results
    print(f"\n=== PRICING RESULTS ===")
    print(f"Conservative Note:")
    print(f"  Present Value: ${conservative_pv:,.0f}")
    print(f"  Purchase Percentage: {(conservative_pv/notional)*100:.2f}%")

    print(f"\nAggressive Note:")
    print(f"  Present Value: ${aggressive_pv:,.0f}")
    print(f"  Purchase Percentage: {(aggressive_pv/notional)*100:.2f}%")

    print(f"\n=== GREEKS (Conservative Note) ===")
    print(f"Delta: {greeks['delta']:.4f}")
    print(f"Gamma: {greeks['gamma']:.6f}")
    print(f"Vega: {greeks['vega']:.2f}")
    print(f"Jump Sensitivity: {greeks['jump_sensitivity']:.2f}")

    print(f"\n=== MODEL COMPARISON INSIGHTS ===")
    print(f"Jump Intensity: {bates_params['jump_intensity']:.3f} jumps/year")
    print(f"Average Jump Size: {bates_params['jump_mean']:.3f}")
    print(f"Jump Volatility: {bates_params['jump_std']:.3f}")
    print(f"The Bates model accounts for sudden market movements that")
    print(f"could trigger early autocalls or breach protection barriers.")


if __name__ == "__main__":
    main_example()